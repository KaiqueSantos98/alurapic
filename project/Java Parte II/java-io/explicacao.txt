package br.com.semprenavegando.util;

import javax.persistence.EntityManager;

class FacoOutraCoisa implements FacoAlgo {
	@Override // Sobreescreve o método da Interface.... a classe agora pode dizer o que fazer 
    public void executa() {
    	System.out.println("Olá Mundo xD");
    }
}

public class HibernateUtilTest {
	public static void main(String[] args) {
		
		EntityManager manager = JpaUtil.getEntityManagerFactory();
		
		    JPA                 Hibernate/OpenJPA/EclipseLink
		    voce troca a Implementacao e nada para de funcionar saco? sim, pq ele mantem tudo funcionando
		    		isso mesmo. 
		FacoAlgo trocoCanal = new FacoOutraCoisa();
		
		// você troca a Implementacao
		// e mantem a especificao =] LUXO
		// a JPA faz justamente isso ENTENDi
		// veja isso 
		//Controle controle                 = new Controle();
	     // Variavel de Referencia certo?  - new faz o Objeto certo? dcerto
	        
	    trocoCanal.executa();
	    
	    //certobeleza funcionou certo? cetto
	  // digamos que voce precisa troca a classe , mas isso iria custar 100.000 linhas de codigo...
	    // como resolve? Aplicando o polimorfismo. isso veja só
	    // ainda estamos usando a classe certo?yes
	    
	    // a interface faz referencia ao objeto e como ela tem um 'contrato' com ela, quem executa o método é o Objeto
		
	}
}
